{"version":3,"sources":["../../src/abp-filter-parser.js"],"names":[],"mappings":"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","file":"abp-filter-parser.js","sourcesContent":["import * as BloomFilterJS from 'bloom-filter-js';\nimport {badFingerprints, badSubstrings} from './badFingerprints.js';\n\n/**\n * bitwise mask of different request types\n */\nexport const elementTypes = {\n  SCRIPT: 0o1,\n  IMAGE: 0o2,\n  STYLESHEET: 0o4,\n  OBJECT: 0o10,\n  XMLHTTPREQUEST: 0o20,\n  OBJECTSUBREQUEST: 0o40,\n  SUBDOCUMENT: 0o100,\n  DOCUMENT: 0o200,\n  OTHER: 0o400,\n};\n\n// Maximum number of cached entries to keep for subsequent lookups\nconst maxCached = 100;\n\n// Maximum number of URL chars to check in match clauses\nconst maxUrlChars = 100;\n\n// Exact size for fingerprints, if you change also change fingerprintRegexs\nconst fingerprintSize = 8;\n\n// Regexes used to create fingerprints\n// There's more than one because sometimes a fingerprint is determined to be a bad\n// one and would lead to a lot of collisions in the bloom filter). In those cases\n// we use the 2nd fingerprint.\nlet fingerprintRegexs = [\n  /.*([./&_\\-=a-zA-Z0-9]{8})\\$?.*/,\n  /([./&_\\-=a-zA-Z0-9]{8})\\$?.*/,\n];\n\n/**\n * Maps element types to type mask.\n */\nexport const elementTypeMaskMap = new Map([\n  ['script', elementTypes.SCRIPT],\n  ['image', elementTypes.IMAGE],\n  ['stylesheet', elementTypes.STYLESHEET],\n  ['object', elementTypes.OBJECT],\n  ['xmlhttprequest', elementTypes.XMLHTTPREQUEST],\n  ['object-subrequest', elementTypes.OBJECTSUBREQUEST],\n  ['subdocument', elementTypes.SUBDOCUMENT],\n  ['document', elementTypes.DOCUMENT],\n  ['other', elementTypes.OTHER]\n]);\n\nconst separatorCharacters = ':?/=^';\n\n/**\n * Parses the domain string using the passed in separator and\n * fills in options.\n */\nexport function parseDomains(input, separator, options) {\n  options.domains = options.domains || [];\n  options.skipDomains = options.skipDomains || [];\n  let domains = input.split(separator);\n  options.domains = options.domains.concat(domains.filter((domain) => domain[0] !== '~'));\n  options.skipDomains = options.skipDomains.concat(domains\n    .filter((domain) => domain[0] === '~')\n    .map((domain) => domain.substring(1)));\n}\n\n/**\n * Parses options from the passed in input string\n */\nexport function parseOptions(input) {\n  let output = {\n    binaryOptions: new Set(),\n  };\n  input.split(',').forEach((option) => {\n    option = option.trim();\n    if (option.startsWith('domain=')) {\n      let domainString = option.split('=')[1].trim();\n      parseDomains(domainString, '|', output);\n    } else {\n      let optionWithoutPrefix = option[0] === '~' ? option.substring(1) : option;\n      if (elementTypeMaskMap.has(optionWithoutPrefix)) {\n        if (option[0] === '~') {\n          output.skipElementTypeMask |= elementTypeMaskMap.get(optionWithoutPrefix);\n        } else {\n          output.elementTypeMask |= elementTypeMaskMap.get(optionWithoutPrefix);\n        }\n      }\n      output.binaryOptions.add(option);\n    }\n  });\n  return output;\n}\n\n/**\n * Finds the first separator character in the input string\n */\nfunction findFirstSeparatorChar(input, startPos) {\n  for (let i = startPos; i < input.length; i++) {\n    if (separatorCharacters.indexOf(input[i]) !== -1) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n/**\n * Parses an HTML filter and modifies the passed in parsedFilterData\n * as necessary.\n *\n * @param input: The entire input string to consider\n * @param index: Index of the first hash\n * @param parsedFilterData: The parsedFilterData object to fill\n */\nexport function parseHTMLFilter(input, index, parsedFilterData) {\n  let domainsStr = input.substring(0, index);\n  parsedFilterData.options = {};\n  if (domainsStr.length > 0) {\n    parseDomains(domainsStr, ',', parsedFilterData.options);\n  }\n\n  // The XOR parsedFilterData.elementHidingException is in case the rule already\n  // was specified as exception handling with a prefixed @@\n  parsedFilterData.isException = !!(input[index + 1] === '@' ^\n    parsedFilterData.isException);\n  if (input[index + 1] === '@') {\n    // Skip passed the first # since @# is 2 chars same as ##\n    index++;\n  }\n  parsedFilterData.htmlRuleSelector = input.substring(index + 2);\n}\n\nexport function parseFilter(input, parsedFilterData, bloomFilter, exceptionBloomFilter) {\n  input = input.trim();\n\n  // Check for comment or nothing\n  if (input.length === 0) {\n    return false;\n  }\n\n  // Check for comments\n  let beginIndex = 0;\n  if (input[beginIndex] === '[' || input[beginIndex] === '!') {\n    parsedFilterData.isComment = true;\n    return false;\n  }\n\n  // Check for exception instead of filter\n  parsedFilterData.isException = input[beginIndex] === '@' &&\n    input[beginIndex + 1] === '@';\n  if (parsedFilterData.isException) {\n    beginIndex = 2;\n  }\n\n  // Check for element hiding rules\n  let index = input.indexOf('#', beginIndex);\n  if (index !== -1) {\n    if (input[index + 1] === '#' || input[index + 1] === '@') {\n      parseHTMLFilter(input.substring(beginIndex), index - beginIndex, parsedFilterData);\n      // HTML rules cannot be combined with other parsing,\n      // other than @@ exception marking.\n      return true;\n    }\n  }\n\n  // Check for options, regex can have options too so check this before regex\n  index = input.indexOf('$', beginIndex);\n  if (index !== -1) {\n    parsedFilterData.options = parseOptions(input.substring(index + 1));\n    // Get rid of the trailing options for the rest of the parsing\n    input = input.substring(0, index);\n  } else {\n    parsedFilterData.options = {};\n  }\n\n  // Check for a regex\n  parsedFilterData.isRegex = input[beginIndex] === '/' &&\n    input[input.length - 1] === '/' && beginIndex !== input.length - 1;\n  if (parsedFilterData.isRegex) {\n    parsedFilterData.data = input.slice(beginIndex + 1, -1);\n    return true;\n  }\n\n  // Check if there's some kind of anchoring\n  if (input[beginIndex] === '|') {\n    // Check for an anchored domain name\n    if (input[beginIndex + 1] === '|') {\n      parsedFilterData.hostAnchored = true;\n      let indexOfSep = findFirstSeparatorChar(input, beginIndex + 1);\n      if (indexOfSep === -1) {\n        indexOfSep = input.length;\n      }\n      beginIndex += 2;\n      parsedFilterData.host = input.substring(beginIndex, indexOfSep);\n    } else {\n      parsedFilterData.leftAnchored = true;\n      beginIndex++;\n    }\n  }\n  if (input[input.length - 1] === '|') {\n    parsedFilterData.rightAnchored = true;\n    input = input.substring(0, input.length - 1);\n  }\n\n  parsedFilterData.data = input.substring(beginIndex) || '*';\n  // Use the host bloom filter if the filter is a host anchored filter rule with no other data\n  if (exceptionBloomFilter && parsedFilterData.isException) {\n    exceptionBloomFilter.add(getFingerprint(parsedFilterData.data));\n  } else if (bloomFilter) {\n    // To check for duplicates\n    //if (bloomFilter.exists(getFingerprint(parsedFilterData.data))) {\n      // console.log('duplicate found for data: ' + getFingerprint(parsedFilterData.data));\n    //}\n    // console.log('parse:', parsedFilterData.data, 'fingerprint:', getFingerprint(parsedFilterData.data));\n    bloomFilter.add(getFingerprint(parsedFilterData.data));\n  }\n\n  return true;\n}\n\n/**\n * Parses the set of filter rules and fills in parserData\n * @param input filter rules\n * @param parserData out parameter which will be filled\n *   with the filters, exceptionFilters and htmlRuleFilters.\n */\nexport function parse(input, parserData) {\n  parserData.bloomFilter = parserData.bloomFilter || new BloomFilterJS.BloomFilter();\n  parserData.exceptionBloomFilter = parserData.exceptionBloomFilter || new BloomFilterJS.BloomFilter();\n  parserData.filters = parserData.filters || [];\n  parserData.noFingerprintFilters = parserData.noFingerprintFilters || [];\n  parserData.exceptionFilters = parserData.exceptionFilters || [];\n  parserData.htmlRuleFilters = parserData.htmlRuleFilters || [];\n  let startPos = 0;\n  let endPos = input.length;\n  let newline = '\\n';\n  while (startPos <= input.length) {\n    endPos = input.indexOf(newline, startPos);\n    if (endPos === -1) {\n      newline = '\\r';\n      endPos = input.indexOf(newline, startPos);\n    }\n    if (endPos === -1) {\n      endPos = input.length;\n    }\n    let filter = input.substring(startPos, endPos);\n    let parsedFilterData = {};\n    if (parseFilter(filter, parsedFilterData, parserData.bloomFilter, parserData.exceptionBloomFilter)) {\n      let fingerprint = getFingerprint(parsedFilterData.data);\n      if (parsedFilterData.htmlRuleSelector) {\n        parserData.htmlRuleFilters.push(parsedFilterData);\n      } else if (parsedFilterData.isException) {\n        parserData.exceptionFilters.push(parsedFilterData);\n      } else if (fingerprint.length > 0) {\n        parserData.filters.push(parsedFilterData);\n      } else {\n        parserData.noFingerprintFilters.push(parsedFilterData);\n      }\n    }\n    startPos = endPos + 1;\n  }\n}\n\n/**\n * Obtains the domain index of the input filter line\n */\nfunction getDomainIndex(input) {\n  let index = input.indexOf(':');\n  ++index;\n  while (input[index] === '/') {\n    index++;\n  }\n  return index;\n}\n\n/**\n * Similar to str1.indexOf(filter, startingPos) but with\n * extra consideration to some ABP filter rules like ^.\n */\nfunction indexOfFilter(input, filter, startingPos) {\n  if (filter.length > input.length) {\n    return -1;\n  }\n\n  let filterParts = filter.split('^');\n  let index = startingPos;\n  let beginIndex = -1;\n  let prefixedSeparatorChar = false;\n\n  for (let f = 0; f < filterParts.length; f++) {\n    if (filterParts[f] === '') {\n      prefixedSeparatorChar = true;\n      continue;\n    }\n\n    index = input.indexOf(filterParts[f], index);\n    if (index === -1) {\n      return -1;\n    }\n    if (beginIndex === -1) {\n      beginIndex = index;\n    }\n\n    if (prefixedSeparatorChar) {\n      if (separatorCharacters.indexOf(input[index - 1]) === -1) {\n        return -1;\n      }\n    }\n    // If we are in an in between filterPart\n    if (f + 1 < filterParts.length &&\n        // and we have some chars left in the input past the last filter match\n        input.length > index + filterParts[f].length) {\n      if (separatorCharacters.indexOf(input[index + filterParts[f].length]) === -1) {\n        return -1;\n      }\n\n    }\n\n    prefixedSeparatorChar = false;\n  }\n  return beginIndex;\n}\n\nfunction getUrlHost(input) {\n  let domainIndexStart = getDomainIndex(input);\n  let domainIndexEnd = findFirstSeparatorChar(input, domainIndexStart);\n  if (domainIndexEnd === -1) {\n    domainIndexEnd = input.length;\n  }\n  return input.substring(domainIndexStart, domainIndexEnd);\n}\n\nfunction filterDataContainsOption(parsedFilterData, option) {\n  return parsedFilterData.options &&\n    parsedFilterData.options.binaryOptions &&\n    parsedFilterData.options.binaryOptions.has(option);\n}\n\nfunction isThirdPartyHost(baseContextHost, testHost) {\n  if (!testHost.endsWith(baseContextHost)) {\n    return true;\n  }\n\n  let c = testHost[testHost.length - baseContextHost.length - 1];\n  return c !== '.' && c !== undefined;\n}\n\n// Determines if there's a match based on the options, this doesn't\n// mean that the filter rule shoudl be accepted, just that the filter rule\n// should be considered given the current context.\n// By specifying context params, you can filter out the number of rules which are\n// considered.\nfunction matchOptions(parsedFilterData, input, contextParams = {}) {\n  if (contextParams.elementTypeMask !== undefined && parsedFilterData.options) {\n    if (parsedFilterData.options.elementTypeMask !== undefined &&\n        !(parsedFilterData.options.elementTypeMask & contextParams.elementTypeMask)) {\n      return false;\n    } if (parsedFilterData.options.skipElementTypeMask !== undefined &&\n          parsedFilterData.options.skipElementTypeMask & contextParams.elementTypeMask) {\n      return false;\n    }\n  }\n\n  // Domain option check\n  if (contextParams.domain !== undefined && parsedFilterData.options) {\n    if (parsedFilterData.options.domains || parsedFilterData.options.skipDomains) {\n      // Get the domains that should be considered\n      let shouldBlockDomains = parsedFilterData.options.domains.filter((domain) =>\n        !isThirdPartyHost(domain, contextParams.domain));\n\n      let shouldSkipDomains = parsedFilterData.options.skipDomains.filter((domain) =>\n        !isThirdPartyHost(domain, contextParams.domain));\n      // Handle cases like: example.com|~foo.example.com should llow for foo.example.com\n      // But ~example.com|foo.example.com should block for foo.example.com\n      let leftOverBlocking = shouldBlockDomains.filter((shouldBlockDomain) =>\n        shouldSkipDomains.every((shouldSkipDomain) =>\n          isThirdPartyHost(shouldBlockDomain, shouldSkipDomain)));\n      let leftOverSkipping = shouldSkipDomains.filter((shouldSkipDomain) =>\n        shouldBlockDomains.every((shouldBlockDomain) =>\n          isThirdPartyHost(shouldSkipDomain, shouldBlockDomain)));\n\n      // If we have none left over, then we shouldn't consider this a match\n      if (shouldBlockDomains.length === 0 && parsedFilterData.options.domains.length !== 0 ||\n          shouldBlockDomains.length > 0 && leftOverBlocking.length === 0 ||\n          shouldSkipDomains.length > 0 && leftOverSkipping.length > 0) {\n        return false;\n      }\n    }\n  }\n\n  // If we're in the context of third-party site, then consider third-party option checks\n  if (contextParams['third-party'] !== undefined) {\n    // Is the current rule check for third party only?\n    if (filterDataContainsOption(parsedFilterData, 'third-party')) {\n      let inputHost = getUrlHost(input);\n      let inputHostIsThirdParty = isThirdPartyHost(parsedFilterData.host, inputHost);\n      if (inputHostIsThirdParty || !contextParams['third-party']) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\n/**\n * Given an individual parsed filter data determines if the input url should block.\n */\nexport function matchesFilter(parsedFilterData, input, contextParams = {}, cachedInputData = {}) {\n  if (!matchOptions(parsedFilterData, input, contextParams)) {\n    return false;\n  }\n\n  // Check for a regex match\n  if (parsedFilterData.isRegex) {\n    if (!parsedFilterData.regex) {\n      parsedFilterData.regex = new RegExp(parsedFilterData.data);\n    }\n    return parsedFilterData.regex.test(input);\n  }\n\n  // Check for both left and right anchored\n  if (parsedFilterData.leftAnchored && parsedFilterData.rightAnchored) {\n    return parsedFilterData.data === input;\n  }\n\n  // Check for right anchored\n  if (parsedFilterData.rightAnchored) {\n    return input.slice(-parsedFilterData.data.length) === parsedFilterData.data;\n  }\n\n  // Check for left anchored\n  if (parsedFilterData.leftAnchored) {\n    return input.substring(0, parsedFilterData.data.length) === parsedFilterData.data;\n  }\n\n  // Check for domain name anchored\n  if (parsedFilterData.hostAnchored) {\n    if (!cachedInputData.currentHost) {\n      cachedInputData.currentHost = getUrlHost(input);\n    }\n\n    return !isThirdPartyHost(parsedFilterData.host, cachedInputData.currentHost) &&\n      indexOfFilter(input, parsedFilterData.data) !== -1;\n  }\n\n  // Wildcard match comparison\n  let parts = parsedFilterData.data.split('*');\n  let index = 0;\n  for (let part of parts) {\n    let newIndex = indexOfFilter(input, part, index);\n    if (newIndex === -1) {\n      return false;\n    }\n    index = newIndex + part.length;\n  }\n\n  return true;\n}\n\nfunction discoverMatchingPrefix(array, bloomFilter, str, prefixLen = fingerprintSize) {\n  for (var i = 0; i < str.length - prefixLen + 1; i++) {\n    let sub = str.substring(i, i + prefixLen);\n    if (bloomFilter.exists(sub)) {\n      array.push({ badFingerprint: sub, src: str});\n      // console.log('bad-fingerprint:', sub, 'for url:', str);\n    } else {\n      // console.log('good-fingerprint:', sub, 'for url:', str);\n    }\n  }\n}\n\nfunction hasMatchingFilters(filterList, parsedFilterData, input, contextParams, cachedInputData) {\n  return filterList.some((parsedFilterData) =>\n    matchesFilter(parsedFilterData, input, contextParams, cachedInputData));\n}\n\n/**\n * Using the parserData rules will try to see if the input URL should be blocked or not\n * @param parserData The filter data obtained from a call to parse\n * @param input The input URL\n * @return true if the URL should be blocked\n */\nexport function matches(parserData, input, contextParams = {}, cachedInputData = { }) {\n  cachedInputData.bloomNegativeCount = cachedInputData.bloomNegativeCount || 0;\n  cachedInputData.bloomPositiveCount = cachedInputData.bloomPositiveCount || 0;\n  cachedInputData.notMatchCount = cachedInputData.notMatchCount || 0;\n  cachedInputData.badFingerprints = cachedInputData.badFingerprints || [];\n  cachedInputData.bloomFalsePositiveCount = cachedInputData.bloomFalsePositiveCount || 0;\n  let hasMatchingNoFingerprintFilters;\n  let cleanedInput = input.replace(/^https?:\\/\\//, '');\n  if (cleanedInput.length > maxUrlChars) {\n    cleanedInput = cleanedInput.substring(0, maxUrlChars);\n  }\n  if (parserData.bloomFilter) {\n    if (!parserData.bloomFilter.substringExists(cleanedInput, fingerprintSize)) {\n      cachedInputData.bloomNegativeCount++;\n      cachedInputData.notMatchCount++;\n      // console.log('early return because of bloom filter check!');\n      hasMatchingNoFingerprintFilters =\n        hasMatchingFilters(parserData.noFingerprintFilters, parserData, input, contextParams, cachedInputData);\n\n      if (!hasMatchingNoFingerprintFilters) {\n        return false;\n      }\n    }\n    // console.log('looked for url in bloom filter and it said yes:', cleaned);\n  }\n  cachedInputData.bloomPositiveCount++;\n\n  // console.log('not early return: ', input);\n  delete cachedInputData.currentHost;\n  cachedInputData.misses = cachedInputData.misses || new Set();\n  cachedInputData.missList = cachedInputData.missList || [];\n  if (cachedInputData.missList.length > maxCached) {\n    cachedInputData.misses.delete(cachedInputData.missList[0]);\n    cachedInputData.missList = cachedInputData.missList.splice(1);\n  }\n  if (cachedInputData.misses.has(input)) {\n    cachedInputData.notMatchCount++;\n    // console.log('positive match for input: ', input);\n    return false;\n  }\n\n  if (hasMatchingFilters(parserData.filters, parserData, input, contextParams, cachedInputData) ||\n      hasMatchingNoFingerprintFilters === true || hasMatchingNoFingerprintFilters === undefined &&\n      hasMatchingFilters(parserData.noFingerprintFilters, parserData, input, contextParams, cachedInputData)) {\n    // Check for exceptions only when there's a match because matches are\n    // rare compared to the volume of checks\n    let exceptionBloomFilterMiss = parserData.exceptionBloomFilter && !parserData.exceptionBloomFilter.substringExists(cleanedInput, fingerprintSize);\n    if (!exceptionBloomFilterMiss || hasMatchingFilters(parserData.exceptionFilters, parserData, input, contextParams, cachedInputData)) {\n      cachedInputData.notMatchCount++;\n      return false;\n    }\n    return true;\n  }\n\n  // The bloom filter had a false positive, se we checked for nothing! :'(\n  // This is probably (but not always) an indication that the fingerprint selection should be tweaked!\n  cachedInputData.missList.push(input);\n  cachedInputData.misses.add(input);\n  cachedInputData.notMatchCount++;\n  cachedInputData.bloomFalsePositiveCount++;\n  discoverMatchingPrefix(cachedInputData.badFingerprints, parserData.bloomFilter, cleanedInput);\n  // console.log('positive match for input: ', input);\n  return false;\n}\n\n/**\n * Obtains a fingerprint for the specified filter\n */\nexport function getFingerprint(str) {\n  for (var i = 0; i < fingerprintRegexs.length; i++) {\n    let fingerprintRegex = fingerprintRegexs[i];\n    let result = fingerprintRegex.exec(str);\n    fingerprintRegex.lastIndex = 0;\n\n    if (result &&\n        !badFingerprints.includes(result[1]) &&\n        !badSubstrings.find(badSubstring => result[1].includes(badSubstring))) {\n      return result[1];\n    }\n    if (result) {\n      // console.log('checking again for str:', str, 'result:', result[1]);\n    } else {\n      // console.log('checking again for str, no result');\n    }\n  }\n  // This is pretty ugly but getting fingerprints is assumed to be used only when preprocessing and\n  // in a live environment.\n  if (str.length > 8) {\n    // Remove first and last char\n    return getFingerprint(str.slice(1, -1));\n  }\n  // console.warn('Warning: Could not determine a good fingerprint for:', str);\n  return '';\n}\n"]}